# File: /opt/access_control/src/external/odoo_partner_connector.py
# Connettore Odoo per controllo accessi
# Solo 4 campi essenziali: CF, name, city, active

import xmlrpc.client
import logging
import time
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import threading
import re
from pathlib import Path

logger = logging.getLogger(__name__)

class OdooPartnerConnector:
    """Connettore Odoo ROBUSTO per cittadini - Solo campi essenziali"""
    
    def __init__(self, config_manager):
        self.config = config_manager.get_config()
        
        # Connessioni XML-RPC
        self.common_proxy = None
        self.object_proxy = None
        self.uid = None
        
        # Stato connessione
        self.is_connected = False
        self.last_sync = None
        self.sync_errors = 0
        self.max_sync_errors = 3
        
        # Thread sincronizzazione
        self.sync_thread = None
        self.running = False
        
        # Cache file
        self.cache_file = Path("/opt/access_control/data/partner_cache.json")
        self.cache_file.parent.mkdir(parents=True, exist_ok=True)
        
        logger.info("üîó OdooPartnerConnector ROBUSTO inizializzato")
    
    def configure_connection(self, url: str, database: str, username: str, password: str,
                           comune: str = "Rende", sync_interval: int = 43200):
        """Configura connessione Odoo ROBUSTA"""
        
        # Assicura protocollo HTTPS
        if not url.startswith(('http://', 'https://')):
            url = f"https://{url}"
        
        self.odoo_url = url.rstrip('/')
        self.odoo_database = database
        self.odoo_username = username
        self.odoo_password = password
        self.comune_filter = comune
        self.sync_interval = sync_interval
        
        # URLs XML-RPC
        self.common_url = f"{self.odoo_url}/xmlrpc/2/common"
        self.object_url = f"{self.odoo_url}/xmlrpc/2/object"
        
        logger.info(f"üìù Odoo configurato per {comune}: {url}/{database}")
    
    def test_connection(self) -> Tuple[bool, str]:
        """Test connessione ROBUSTO con timeout"""
        try:
            logger.info(f"üîç Test connessione {self.odoo_url}...")
            
            # Test endpoint common con timeout
            common = xmlrpc.client.ServerProxy(self.common_url)
            version_info = common.version()
            
            server_version = version_info.get('server_version', 'Unknown')
            logger.info(f"‚úÖ Server Odoo: {server_version}")
            
            # Test autenticazione
            uid = common.authenticate(self.odoo_database, self.odoo_username, self.odoo_password, {})
            
            if not uid:
                return False, "‚ùå Autenticazione fallita - controllare credenziali"
            
            logger.info(f"‚úÖ Autenticazione OK - UID: {uid}")
            
            # Test accesso res.partner con SOLO campi necessari
            models = xmlrpc.client.ServerProxy(self.object_url)
            
            # Test count con filtri ESATTI
            domain_test = [
                ('city', '=', self.comune_filter),
                ('is_person', '=', True),
                ('is_company', '=', False),
                ('is_ente', '=', False),
                ('l10n_it_codice_fiscale', '!=', False),
                ('l10n_it_codice_fiscale', '!=', '')
            ]
            
            test_count = models.execute_kw(
                self.odoo_database, uid, self.odoo_password,
                'res.partner', 'search_count', [domain_test]
            )
            
            if test_count == 0:
                return False, f"‚ö†Ô∏è Nessun cittadino per {self.comune_filter} - verificare dati"
            
            logger.info(f"‚úÖ Test OK: {test_count} cittadini {self.comune_filter}")
            return True, f"‚úÖ Connessione OK - {test_count} cittadini disponibili"
                
        except Exception as e:
            return False, f"‚ùå Errore connessione: {e}"
    
    def connect(self) -> bool:
        """Stabilisce connessione Odoo ROBUSTA"""
        try:
            if not all([self.odoo_url, self.odoo_database, self.odoo_username, self.odoo_password]):
                logger.error("‚ùå Configurazione Odoo incompleta")
                return False
            
            # Connessioni XML-RPC
            self.common_proxy = xmlrpc.client.ServerProxy(self.common_url)
            self.object_proxy = xmlrpc.client.ServerProxy(self.object_url)
            
            # Autenticazione
            self.uid = self.common_proxy.authenticate(
                self.odoo_database, self.odoo_username, self.odoo_password, {}
            )
            
            if self.uid:
                self.is_connected = True
                self.sync_errors = 0
                logger.info(f"‚úÖ Connesso a Odoo - UID: {self.uid}")
                return True
            else:
                logger.error("‚ùå Autenticazione Odoo fallita")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Errore connessione: {e}")
            return False
    
    def fetch_cittadini_autorizzati(self) -> List[Dict]:
        """Recupera cittadini SOLO con campi essenziali
        
        Returns:
            Lista dizionari con dati cittadini essenziali
        """
        try:
            if not self.is_connected and not self.connect():
                logger.warning("‚ö†Ô∏è Connessione Odoo non disponibile - uso cache")
                return self._load_from_cache()
            
            # Domain ROBUSTO per filtri
            domain = [
                ('city', '=', self.comune_filter),
                ('is_person', '=', True),
                ('is_company', '=', False),
                ('is_ente', '=', False),
                ('l10n_it_codice_fiscale', '!=', False),
                ('l10n_it_codice_fiscale', '!=', ''),
                ('active', '=', True)  # Solo attivi
            ]
            
            # SOLO 4 campi essenziali - PERFORMANCE OTTIMIZZATA
            fields = [
                'l10n_it_codice_fiscale',  # CF per identificazione
                'name',                    # Nome completo per log
                'city',                    # Citt√† per verifica
                'active'                   # Stato attivo
            ]
            
            logger.info(f"üì• Recupero cittadini {self.comune_filter} - SOLO campi essenziali...")
            
            # Ricerca IDs con LIMIT per sicurezza
            partner_ids = self.object_proxy.execute_kw(
                self.odoo_database, self.uid, self.odoo_password,
                'res.partner', 'search', [domain], {'limit': 30000}
            )
            
            if not partner_ids:
                logger.warning(f"‚ö†Ô∏è Nessun cittadino per {self.comune_filter}")
                return []
            
            logger.info(f"üìã Trovati {len(partner_ids)} cittadini, recupero dati essenziali...")
            
            # Lettura dati in batch per performance
            batch_size = 1000
            all_partners = []
            
            for i in range(0, len(partner_ids), batch_size):
                batch_ids = partner_ids[i:i + batch_size]
                
                batch_partners = self.object_proxy.execute_kw(
                    self.odoo_database, self.uid, self.odoo_password,
                    'res.partner', 'read', [batch_ids], {'fields': fields}
                )
                
                all_partners.extend(batch_partners)
                logger.info(f"üì¶ Batch {i//batch_size + 1}: {len(batch_partners)} record")
            
            # Processamento SEMPLIFICATO e ROBUSTO
            cittadini_validi = []
            errori_cf = 0
            
            for partner in all_partners:
                try:
                    # CF validation ROBUSTA
                    cf = partner.get('l10n_it_codice_fiscale', '').strip().upper()
                    
                    if not self._validate_codice_fiscale(cf):
                        errori_cf += 1
                        continue
                    
                    # Nome completo da Odoo
                    nome = partner.get('name', '').strip()
                    if not nome:
                        nome = 'Cittadino Sconosciuto'
                    
                    # Dati cittadino ESSENZIALI
                    cittadino = {
                        'codice_fiscale': cf,
                        'nome': nome,
                        'note': f"Sync Odoo {datetime.now().strftime('%Y-%m-%d')}",
                        'attivo': partner.get('active', True),
                        'odoo_id': partner.get('id'),
                        'sync_timestamp': datetime.now().isoformat(),
                        'creato_da': 'ODOO_SYNC',
                        'modificato_da': 'ODOO_SYNC'
                    }
                    
                    cittadini_validi.append(cittadino)
                    
                except Exception as e:
                    errori_cf += 1
                    logger.debug(f"‚ö†Ô∏è Errore partner {partner.get('id')}: {e}")
            
            # Statistiche finali
            logger.info(f"‚úÖ Processati {len(cittadini_validi)} cittadini validi")
            if errori_cf > 0:
                logger.warning(f"‚ö†Ô∏è {errori_cf} record con CF invalido/mancante")
            
            # Salva in cache
            self._save_to_cache(cittadini_validi)
            
            return cittadini_validi
            
        except Exception as e:
            logger.error(f"‚ùå Errore recupero cittadini: {e}")
            self.sync_errors += 1
            
            # Fallback cache
            logger.info("üîÑ Fallback su cache locale")
            return self._load_from_cache()
    
    def _validate_codice_fiscale(self, cf: str) -> bool:
        """Validazione CF ROBUSTA"""
        if not cf or len(cf) != 16:
            return False
        
        # Pattern CF italiano
        pattern = r'^[A-Z]{6}[0-9]{2}[A-Z][0-9]{2}[A-Z][0-9]{3}[A-Z]$'
        if not re.match(pattern, cf):
            return False
        
        # Evita pattern troppo uniformi (test data)
        if len(set(cf)) < 6:
            return False
        
        return True
    
    def _save_to_cache(self, cittadini: List[Dict]):
        """Salva cittadini in cache locale ROBUSTA"""
        try:
            cache_data = {
                'timestamp': datetime.now().isoformat(),
                'comune': self.comune_filter,
                'count': len(cittadini),
                'cittadini': cittadini
            }
            
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, indent=2, ensure_ascii=False, default=str)
            
            logger.info(f"üíæ Cache salvata: {len(cittadini)} cittadini")
            
        except Exception as e:
            logger.error(f"‚ùå Errore salvataggio cache: {e}")
    
    def _load_from_cache(self) -> List[Dict]:
        """Carica cittadini da cache locale"""
        try:
            if not self.cache_file.exists():
                logger.warning("‚ö†Ô∏è Cache locale non esistente")
                return []
            
            with open(self.cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            cittadini = cache_data.get('cittadini', [])
            timestamp = cache_data.get('timestamp', 'Unknown')
            
            logger.info(f"üìÇ Cache: {len(cittadini)} cittadini ({timestamp})")
            return cittadini
            
        except Exception as e:
            logger.error(f"‚ùå Errore caricamento cache: {e}")
            return []
    
    def sync_to_database(self, database_manager) -> Tuple[bool, Dict]:
        """Sincronizza cittadini con database locale ROBUSTO"""
        start_time = time.time()
        stats = {'fetched': 0, 'updated': 0, 'added': 0, 'errors': 0, 'skipped': 0}
        
        try:
            logger.info(f"üîÑ Sync ROBUSTA cittadini {self.comune_filter}")
            
            # Recupera cittadini
            cittadini = self.fetch_cittadini_autorizzati()
            stats['fetched'] = len(cittadini)
            
            if not cittadini:
                logger.warning("‚ö†Ô∏è Nessun cittadino da sincronizzare")
                return False, stats
            
            # Sincronizzazione ROBUSTA
            for cittadino in cittadini:
                try:
                    cf = cittadino['codice_fiscale']
                    
                    # Verifica esistenza
                    exists, existing_user = database_manager.verify_access(cf)
                    
                    if exists:
                        # Gi√† presente - skip
                        stats['skipped'] += 1
                    else:
                        # Aggiungi nuovo cittadino
                        success = database_manager.add_user(
                            codice_fiscale=cf,
                            nome=cittadino['nome'],
                            note=cittadino['note'],
                            creato_da=cittadino['creato_da'],
                            modificato_da=cittadino['modificato_da']
                        )
                        
                        if success:
                            stats['added'] += 1
                            if stats['added'] % 1000 == 0:
                                logger.info(f"üìà Aggiunti {stats['added']} cittadini...")
                        else:
                            stats['errors'] += 1
                
                except Exception as e:
                    stats['errors'] += 1
                    logger.debug(f"‚ö†Ô∏è Errore sync cittadino: {e}")
            
            # Risultati
            self.last_sync = datetime.now()
            duration = time.time() - start_time
            
            logger.info(f"‚úÖ Sync completata in {duration:.2f}s")
            logger.info(f"üìä {stats['added']} aggiunti, {stats['skipped']} esistenti, {stats['errors']} errori")
            
            return True, stats
            
        except Exception as e:
            logger.error(f"‚ùå Errore sincronizzazione: {e}")
            return False, stats
    
    def get_sync_status(self) -> Dict:
        """Status connessione e sincronizzazione"""
        return {
            'connected': self.is_connected,
            'comune': self.comune_filter,
            'last_sync': self.last_sync.isoformat() if self.last_sync else None,
            'sync_errors': self.sync_errors,
            'cache_exists': self.cache_file.exists(),
            'cache_size': self.cache_file.stat().st_size if self.cache_file.exists() else 0
        }
    
    def disconnect(self):
        """Disconnetti da Odoo"""
        self.common_proxy = None
        self.object_proxy = None
        self.uid = None
        self.is_connected = False
        logger.info("üîå Disconnesso da Odoo")

# Factory function
def create_partner_connector(config_manager) -> OdooPartnerConnector:
    """Crea istanza OdooPartnerConnector ROBUSTO"""
    return OdooPartnerConnector(config_manager)
